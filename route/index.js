// Generated by CoffeeScript 1.6.3
var async, cards, categoryMetaData, convertObjectToHtml, convertObjectToText, fetchCardFullContent, fs, htmlEntitiesToText, htmlTagsToText, jquery, jsdom, mkdirp, request, stripHtmlUnexpectedTags, stripMultipleLineReturns, stripMultipleSpaces, trim, typeIsArray, unescapeGarbageCharacters, unescapeXmlEntities, xml2json, _,
  _this = this;

fs = require('fs');

xml2json = require('xml2json');

_ = require('underscore')._;

async = require('async');

request = require('request');

mkdirp = require('mkdirp');

jsdom = require('jsdom');

jquery = fs.readFileSync("./lib/jquery.js", "utf-8");

categoryMetaData = {
  "mindset": {
    "color": "#98366D",
    "backgroundColor": "#8C2A61"
  },
  "code": {
    "color": "#326DA7",
    "backgroundColor": "#1B4E80"
  },
  "architecture-design": {
    "color": "#ED7738",
    "backgroundColor": "#E36E30"
  },
  "process": {
    "color": "#CA3D38",
    "backgroundColor": "#BB312C"
  },
  "distributed-agile": {
    "color": "#FFFFFF",
    "backgroundColor": "#000000"
  },
  "test": {
    "color": "#6DC726",
    "backgroundColor": "#378241"
  }
};

fetchCardFullContent = function(card, cb) {
  var filePath;
  console.log("Requesting a response for url: '" + card.url + "'");
  filePath = "pages/" + card.id + ".html";
  return fs.lstat(filePath, function(err, stats) {
    if (!err && stats.isFile()) {
      return fs.readFile(filePath, function(err, body) {
        return jsdom.env({
          html: body,
          src: [jquery],
          done: function(err, window) {
            var fullContent;
            if (err) {
              cb(err);
            } else {
              window.$("#card_images").remove();
              fullContent = window.$("#main-content").html();
              card.fullContent = trim(unescapeGarbageCharacters(unescapeXmlEntities(stripMultipleSpaces(stripMultipleLineReturns(stripHtmlUnexpectedTags(fullContent))))));
              cb(null, card);
            }
            return window.close();
          }
        });
      });
    } else {
      return request.get(card.url, function(err, response, body) {
        if (err) {
          console.log("Could not get Url: " + card.url + ", Error: '" + err.message + "'");
          return cb(err);
        } else if (response.statusCode !== 200) {
          return cb(new Error("Status code - " + response.statusCode));
        } else {
          console.log("Got a response for url: '" + card.url + "'");
          return jsdom.env({
            html: body,
            src: [jquery],
            done: function(err, window) {
              if (err) {
                cb(err);
              } else {
                window.$("#card_images").remove();
                card.fullContent = window.$("#main-content").html();
                card.fullContent = trim(unescapeGarbageCharacters(unescapeXmlEntities(stripMultipleSpaces(stripMultipleLineReturns(stripHtmlUnexpectedTags(card.fullContent))))));
                cb(null, card);
                mkdirp("pages", function(err) {
                  if (!err || err.code === 'EEXIST') {
                    return fs.writeFile(filePath, body);
                  }
                });
              }
              return window.close();
            }
          });
        }
      });
    }
  });
};

cards = function(req, res) {
  var categories, data, dataAsXml, deck;
  res.charset = 'UTF-8';
  dataAsXml = fs.readFileSync('./data/cards.xml');
  data = xml2json.toJson(dataAsXml, {
    trim: false,
    object: true
  });
  deck = data.deck;
  categories = deck.categories.category;
  delete deck.categories;
  _(categories).each(function(category) {
    delete category.cmyk;
    category.backgroundColor = categoryMetaData[category.id].backgroundColor;
    delete category["background-color"];
    return category.color = categoryMetaData[category.id].color;
  });
  deck.cards = deck.card;
  delete deck.card;
  _(deck.cards).each(function(card) {
    if (card.altid) {
      card.id = card.altid;
      delete card.altid;
    }
    card.category = _(categories).find(function(category) {
      return card.category === category.id;
    });
    card.sponsors = _(card.sponsors.split(" ")).map(function(sponsor) {
      return {
        id: sponsor
      };
    });
    console.log("Card ID: " + card.id);
    console.log("Card tags: " + card.tags);
    card.tags = !card.tags ? [] : _(card.tags.split(" ")).map(function(tag) {
      return {
        id: tag
      };
    });
    card.title = trim(unescapeGarbageCharacters(unescapeXmlEntities(stripMultipleSpaces(stripMultipleLineReturns(convertObjectToText(card.front))))));
    delete card.front;
    card.note = trim(unescapeGarbageCharacters(unescapeXmlEntities(stripMultipleSpaces(stripMultipleLineReturns(htmlTagsToText(htmlEntitiesToText(card.note)))))));
    card.description = trim(unescapeGarbageCharacters(unescapeXmlEntities(stripMultipleSpaces(stripMultipleLineReturns(htmlEntitiesToText(convertObjectToHtml(card.back)))))));
    delete card.back;
    if (!card.ulink) {
      card.ulink = [];
    }
    if (!Array.isArray(card.ulink)) {
      card.ulink = [card.ulink];
    }
    card.ulinks = card.ulink;
    delete card.ulink;
    card.url = "http://essentials.xebia.com/" + card.id;
    return delete card.bitly;
  });
  return async.map(deck.cards, fetchCardFullContent, function(err, results) {
    if (err) {
      console.log("Could not get card data content");
      return res.send(500, err.message);
    } else {
      console.log("Got full content for " + results.length + " cards");
      return res.json(deck);
    }
  });
};

convertObjectToHtml = function(data) {
  var html, key, result, value;
  html = "";
  for (key in data) {
    value = data[key];
    if (key === "para") {
      if (typeIsArray(value)) {
        html += value.reduce(function(x, y) {
          return "" + x + " " + y;
        });
      } else {
        html += "<p>" + value + "</p>";
      }
    } else if (key === "blockquote") {
      result = convertObjectToHtml(value);
      html += "" + result;
    } else if (key === "ul") {
      result = value.li.map(function(liContent) {
        return "<li>" + liContent + "</li>";
      });
      html += "<ul>" + (result.join("")) + "</ul>";
    } else if (key === "attribution") {
      result = "<p><i>" + value + "</i></p>";
    } else {
      html += "<p>" + value + "</p>";
    }
  }
  return html;
};

convertObjectToText = function(data) {
  var key, text, value;
  text = "";
  for (key in data) {
    value = data[key];
    if (key === "para") {
      if (typeIsArray(value)) {
        text += value.reduce(function(x, y) {
          return "" + x + ", " + y;
        });
      } else {
        text += "" + value;
      }
    } else {
      text += "" + value;
    }
  }
  return htmlTagsToText(htmlEntitiesToText(text));
};

stripHtmlUnexpectedTags = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value.replace(/<p><\/p>/g, "");
  }
};

htmlTagsToText = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value.replace(/<p><\/p>/g, "\n");
  }
};

htmlEntitiesToText = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value.replace(/&apos;/g, "'").replace(/&nbsp;/g, " ");
  }
};

stripMultipleLineReturns = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value.replace(/\n\s*\n/g, '\n');
  }
};

stripMultipleSpaces = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value.replace(/\s{2,}/g, ' ');
  }
};

unescapeXmlEntities = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value.replace(/&#40;/g, "(").replace(/&#41;/g, ")").replace(/&#35;/g, "#").replace(/&amp;#40;/g, "(");
  }
};

trim = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value.trim();
  }
};

unescapeGarbageCharacters = function(value) {
  if (value === void 0) {
    return void 0;
  } else {
    return value;
  }
};

typeIsArray = Array.isArray || function(value) {
  return {}.toString.call(value) === '[object Array]';
};

module.exports = {
  cards: cards
};

/*
//@ sourceMappingURL=index.map
*/
